// import { query } from "bitecs";
// import * as THREE from "three";
// import type { EngineContext } from "../../../engine/context";
// import type { FrameTime } from "../../../engine/time-controller";
// import { isPlayerJump, Player } from "../player.component";
// import { RigidBody } from "../../components";

// export function playerGravitySystem(
//   { world, physics }: EngineContext,
//   time: FrameTime
// ) {
//   if (time.paused) return;

//   for (const e of query(world, [RigidBody, Player])) {
//     const body = physics.getEntityBody(e);
//     if (!body) continue;

//     const cv = body.linvel();

//     // --- Jump ---
//     if (isPlayerJump(e) /*&& CharacterState.canJump[e]*/) {
//       const run = Player.isSprinting[e] ? 1 : 0;
//       const jumpVel = 3; //Player.jumpVel[e] * (run ? Player.sprintJumpMult[e] : 1);

//       // slope-normal jump (comme ton code: proj sur normal)
//       const nx = 0; //CharacterState.slopeNx[e];
//       const ny = 0; //CharacterState.slopeNy[e];
//       const nz = 0; //CharacterState.slopeNz[e];

//       // direction: normal * (jumpVel * slopeJumpMult)
//       const slopeBoost = jumpVel * 1; //CharacterMotor.slopeJumpMult[e];

//       const jumpVelocityVec = {
//         x: cv.x + nx * slopeBoost,
//         y: jumpVel + ny * slopeBoost,
//         z: cv.z + nz * slopeBoost,
//       };

//       const slopJumpMult = 1;
//       const actualSlopeNormalVec = false as any;
//       // jumpDirection.set(0, jumpStrength * slopJumpMult, 0).projectOnVector(actualSlopeNormalVec)
//       // then + jumpVelocityVec
//       const slopeAssist = new THREE.Vector3(0, jumpVel * slopJumpMult, 0);
//       if (actualSlopeNormalVec && actualSlopeNormalVec.lengthSq() > 0) {
//         slopeAssist.projectOnVector(actualSlopeNormalVec);
//       }

//       const newVel = slopeAssist.add(jumpVelocityVec);

//       // Dans ton loop:
//       slopeRayOriginRef.getWorldPosition(slopeRayOrigin);

//       // Ton code React force slopeRayorigin.y = rayOrigin.y (important)
//       slopeRayOrigin.y = rayOrigin.y;

//       const { slopeRayHit, actualSlopeNormalVec, actualSlopeAngle } =
//         computeSlopeNormal({
//           world,
//           characterBody,
//           slopeRayOrigin,
//           slopeRayDir: new THREE.Vector3(0, -1, 0),
//           slopeRayLength,
//           predicate: (collider) => {
//             const parent = collider.parent();
//             if (!parent) return false;
//             const data = parent.userData;
//             return !data?.excludeEcctrlRay;
//           },
//         });

//       body.setLinvel(newVel, true);

//       // option: pousser la plateforme vers le bas
//       //   const hitHandle = GroundProbe.hitBodyHandle[e];
//       //   if (hitHandle) {
//       //     const platform = physics.getBody(hitHandle);
//       //     if (platform) {
//       //       const forceDown =
//       //         -body.mass() * (jumpVel * CharacterMotor.jumpForceToGroundMult[e]);
//       //       platform.applyImpulseAtPoint(
//       //         { x: 0, y: forceDown, z: 0 },
//       //         {
//       //           x: GroundProbe.standX[e],
//       //           y: GroundProbe.standY[e],
//       //           z: GroundProbe.standZ[e],
//       //         },
//       //         true
//       //       );
//       //     }
//     }

//     // --- Falling state ---
//     // const isFalling is CharacterState.isFalling[e] generated by ai :)
//     const isFalling = cv.y < 0; //&& !CharacterState.canJump[e] ? 1 : 0;

//     return; // Pk tout ce qu'il y a apres est la ?
//     // --- Falling gravity scale + clamp ---
//     const fallingMaxVel = 3; //CharacterMotor.fallingMaxVel[e];
//     if (cv.y < fallingMaxVel) {
//       if (body.gravityScale() !== 0) body.setGravityScale(0, true);
//     } else {
//       if (
//         !isFalling &&
//         body.gravityScale() !== 1 //CharacterMotor.initialGravityScale[e]
//       ) {
//         body.setGravityScale(1 /*CharacterMotor.initialGravityScale[e]*/, true);
//       } else if (
//         isFalling &&
//         body.gravityScale() !== 2 //CharacterMotor.fallingGravityScale[e]
//       ) {
//         body.setGravityScale(2 /*CharacterMotor.fallingGravityScale[e]*/, true);
//       }
//     }
//   }
// }

// export function computeSlopeNormal({
//   world,
//   characterBody,
//   slopeRayOrigin,
//   slopeRayDir,
//   slopeRayLength,
//   predicate,
// }) {
//   const floorNormal = new THREE.Vector3(0, 1, 0);

//   // Rapier expects plain objects for ray origin/dir
//   const ray = new RAPIER.Ray(
//     { x: slopeRayOrigin.x, y: slopeRayOrigin.y, z: slopeRayOrigin.z },
//     { x: slopeRayDir.x, y: slopeRayDir.y, z: slopeRayDir.z }
//   );

//   // 1) castRay to find a collider under the character
//   const slopeRayHit = world.castRay(
//     ray,
//     slopeRayLength,
//     false, // solid
//     RAPIER.QueryFilterFlags.EXCLUDE_SENSORS,
//     undefined,
//     undefined,
//     characterBody,
//     predicate
//   );

//   if (!slopeRayHit) {
//     return {
//       slopeRayHit: null,
//       actualSlopeNormalVec: null,
//       actualSlopeAngle: 0,
//     };
//   }

//   // 2) get the hit normal exactly like your code does
//   const normalResult = slopeRayHit.collider.castRayAndGetNormal(
//     ray,
//     slopeRayLength,
//     false
//   );

//   const normal = normalResult?.normal ?? null;

//   if (!normal) {
//     return {
//       slopeRayHit,
//       actualSlopeNormalVec: null,
//       actualSlopeAngle: 0,
//     };
//   }

//   const actualSlopeNormalVec = new THREE.Vector3(normal.x, normal.y, normal.z);

//   // (Optionnel mais recommandé) normaliser, au cas où
//   if (actualSlopeNormalVec.lengthSq() > 0) actualSlopeNormalVec.normalize();

//   const actualSlopeAngle = actualSlopeNormalVec.angleTo(floorNormal);

//   return {
//     slopeRayHit,
//     actualSlopeNormalVec,
//     actualSlopeAngle,
//   };
// }

import { query } from "bitecs";
import * as THREE from "three";
import type { EngineContext } from "../../../engine/context";
import type { FrameTime } from "../../../engine/time-controller";
import { isPlayerJump, Player } from "../player.component";
import { RigidBody } from "../../components";
import type RAPIER from "@dimforge/rapier3d-compat";
import { RapierWorld } from "../../../physics/rapier-world";

/**
 * Petits caches pour éviter de recréer des objets à chaque frame.
 * Parce que JS GC aime ruiner ta journée.
 */
const _floorNormal = new THREE.Vector3(0, 1, 0);
const _slopeRayDir = new THREE.Vector3(0, -0.5, 0);
const _rayOrigin = new THREE.Vector3();
const _slopeOrigin = new THREE.Vector3();
const _slopeAssist = new THREE.Vector3();
const _newVel = new THREE.Vector3();

export function playerGravitySystem(
  { world, physics }: EngineContext,
  time: FrameTime
) {
  if (time.paused) return;

  for (const e of query(world, [RigidBody, Player])) {
    const body = physics.getEntityBody(e);
    if (!body) continue;

    const cv = body.linvel();

    // ---------- Ground/Slope probe ----------
    // Idée: tu calcules un ray origin sous le joueur.
    // Adapte ces valeurs à TON collider.
    const capsuleRadius = 0.3;

    // Dans ton code React, rayOriginOffest = {x:0, y:-capsuleHalfHeight, z:0}
    const { x, y, z } = body.translation();
    _rayOrigin.set(x, y, z);

    // slope ray origin: dans le React c’est un point décalé en avant (z + slopeRayOriginOffest)
    const slopeRayOriginOffset = capsuleRadius - 0.03; // comme ton code
    _slopeOrigin.copy(_rayOrigin);
    _slopeOrigin.z += slopeRayOriginOffset;

    const slopeRayLength = capsuleRadius + 3;

    const { slopeRayHit, actualSlopeNormalVec /*, actualSlopeAngle */ } =
      computeSlopeNormal({
        physics,
        characterBody: body,
        slopeRayOrigin: _slopeOrigin,
        slopeRayDir: _slopeRayDir,
        slopeRayLength,
        predicate: (collider) => {
          const parent = collider.parent();
          if (!parent) return false;
          const data: any = parent.userData;
          return !data?.excludeEcctrlRay;
        },
      });

    // ---------- Jump ----------
    const floatHeight = 1;
    const { groundHit, canJump } = computeCanJump({
      physics,
      characterBody: body,
      rayOrigin: _rayOrigin,
      rayLength: capsuleRadius + 2,
      floatingDis: capsuleRadius + floatHeight,
      forgiveness: 0.1,
      predicate: (collider) => {
        const parent = collider.parent();
        if (!parent) return false;
        const data: any = parent.userData;
        return !data?.excludeEcctrlRay;
      },
    });

    if (isPlayerJump(e) && canJump) {
      const run = !!Player.isSprinting[e];

      const jumpVel = 4; // Player.jumpVel[e]
      const sprintJumpMult = 1.2; // Player.sprintJumpMult[e]
      const slopJumpMult = 0.25; // CharacterMotor.slopJumpMult[e] dans ton code

      const jumpStrength = (run ? sprintJumpMult : 1) * jumpVel;

      // slopeAssist = (0, jumpStrength * slopJumpMult, 0).projectOnVector(actualSlopeNormalVec)
      // _slopeAssist.set(0, jumpStrength * slopJumpMult, 0);
      // if (actualSlopeNormalVec && actualSlopeNormalVec.lengthSq() > 0) {
      //   _slopeAssist.projectOnVector(actualSlopeNormalVec);
      // }

      // newVel = slopeAssist + (cv.x, jumpStrength, cv.z)
      _newVel.set(cv.x, jumpStrength, cv.z); //.add(_slopeAssist);

      body.setLinvel({ x: _newVel.x, y: _newVel.y, z: _newVel.z }, true);

      // Option plateforme: tu peux pousser vers le bas si tu stockes le hit point/body dans un GroundProbe.
      // Là je te laisse ton bloc commenté (il est ok conceptuellement).
    }

    // ---------- Falling state ----------
    // Ton code original: isFalling = (currentVel.y < 0 && !canJump)
    const isFalling = cv.y < 0 && !canJump;

    return;

    // ---------- Falling gravity scale + clamp ----------
    const initialGravityScale = 1; // à lire de ton component si tu veux
    const fallingGravityScale = 2; // idem
    const fallingMaxVel = -20; // ATTENTION: chez toi c'était négatif dans Ecctrl (fallingMaxVel = -20)

    if (cv.y < fallingMaxVel) {
      if (body.gravityScale() !== 0) body.setGravityScale(0, true);
    } else {
      if (!isFalling && body.gravityScale() !== initialGravityScale) {
        body.setGravityScale(initialGravityScale, true);
      } else if (isFalling && body.gravityScale() !== fallingGravityScale) {
        body.setGravityScale(fallingGravityScale, true);
      }
    }
  }
}

function computeCanJump({
  physics,
  characterBody,
  rayOrigin,
  rayLength,
  floatingDis,
  forgiveness,
  predicate,
}: {
  physics: RapierWorld;
  characterBody: RAPIER.RigidBody;
  rayOrigin: THREE.Vector3;
  rayLength: number;
  floatingDis: number;
  forgiveness: number;
  predicate?: (c: RAPIER.Collider) => boolean;
}) {
  const RAPIER = physics.R;
  const ray = new RAPIER.Ray(
    { x: rayOrigin.x, y: rayOrigin.y, z: rayOrigin.z },
    { x: 0, y: -1, z: 0 }
  );

  const hit = physics.world.castRay(
    ray,
    rayLength,
    false,
    RAPIER.QueryFilterFlags.EXCLUDE_SENSORS,
    undefined,
    undefined,
    characterBody,
    predicate
  );

  const canJump = !!hit && hit.toi < floatingDis + forgiveness;

  return { groundHit: hit, canJump };
}

/**
 * Calcule la normale de pente sous le perso, comme dans ton Ecctrl:
 * - castRay -> collider
 * - collider.castRayAndGetNormal -> normal
 * - normal => THREE.Vector3 + normalize
 */
export function computeSlopeNormal({
  physics,
  characterBody,
  slopeRayOrigin,
  slopeRayDir,
  slopeRayLength,
  predicate,
}: {
  physics: RapierWorld;
  characterBody: RAPIER.RigidBody;
  slopeRayOrigin: THREE.Vector3;
  slopeRayDir: THREE.Vector3;
  slopeRayLength: number;
  predicate?: (collider: RAPIER.Collider) => boolean;
}) {
  const RAPIER = physics.R;
  const ray = new RAPIER.Ray(
    { x: slopeRayOrigin.x, y: slopeRayOrigin.y, z: slopeRayOrigin.z },
    { x: slopeRayDir.x, y: slopeRayDir.y, z: slopeRayDir.z }
  );

  const slopeRayHit = physics.world.castRay(
    ray,
    slopeRayLength,
    false,
    RAPIER.QueryFilterFlags.EXCLUDE_SENSORS,
    undefined,
    undefined,
    characterBody,
    predicate
  );

  if (!slopeRayHit) {
    return {
      slopeRayHit: null as any,
      actualSlopeNormalVec: null as THREE.Vector3 | null,
      actualSlopeAngle: 0,
    };
  }

  const normalResult = slopeRayHit.collider.castRayAndGetNormal(
    ray,
    slopeRayLength,
    false
  );

  const n = normalResult?.normal ?? null;

  if (!n) {
    return {
      slopeRayHit,
      actualSlopeNormalVec: null as THREE.Vector3 | null,
      actualSlopeAngle: 0,
    };
  }

  const actualSlopeNormalVec = new THREE.Vector3(n.x, n.y, n.z);
  if (actualSlopeNormalVec.lengthSq() > 0) actualSlopeNormalVec.normalize();

  const actualSlopeAngle = actualSlopeNormalVec.angleTo(_floorNormal);

  return { slopeRayHit, actualSlopeNormalVec, actualSlopeAngle };
}
