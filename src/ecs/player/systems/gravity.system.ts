import { query } from "bitecs";
import * as THREE from "three";
import type { EngineContext } from "../../../engine/context";
import type { FrameTime } from "../../../engine/time-controller";
import { isPlayerJump, Player } from "../player.component";
import { RigidBody } from "../../components";

export function playerGravitySystem(
  { world, physics }: EngineContext,
  time: FrameTime
) {
  if (time.paused) return;

  for (const e of query(world, [RigidBody, Player])) {
    const body = physics.getEntityBody(e);
    if (!body) continue;

    const cv = body.linvel();

    // --- Jump ---
    if (isPlayerJump(e) /*&& CharacterState.canJump[e]*/) {
      const run = Player.isSprinting[e] ? 1 : 0;
      const jumpVel = 3; //Player.jumpVel[e] * (run ? Player.sprintJumpMult[e] : 1);

      // slope-normal jump (comme ton code: proj sur normal)
      const nx = 0; //CharacterState.slopeNx[e];
      const ny = 0; //CharacterState.slopeNy[e];
      const nz = 0; //CharacterState.slopeNz[e];

      // direction: normal * (jumpVel * slopeJumpMult)
      const slopeBoost = jumpVel * 1; //CharacterMotor.slopeJumpMult[e];

      const jumpVelocityVec = {
        x: cv.x + nx * slopeBoost,
        y: jumpVel + ny * slopeBoost,
        z: cv.z + nz * slopeBoost,
      };

      const slopJumpMult = 1;
      const actualSlopeNormalVec = false as any;
      // jumpDirection.set(0, jumpStrength * slopJumpMult, 0).projectOnVector(actualSlopeNormalVec)
      // then + jumpVelocityVec
      const slopeAssist = new THREE.Vector3(0, jumpVel * slopJumpMult, 0);
      if (actualSlopeNormalVec && actualSlopeNormalVec.lengthSq() > 0) {
        slopeAssist.projectOnVector(actualSlopeNormalVec);
      }

      const newVel = slopeAssist.add(jumpVelocityVec);

      body.setLinvel(newVel, true);

      // option: pousser la plateforme vers le bas
      //   const hitHandle = GroundProbe.hitBodyHandle[e];
      //   if (hitHandle) {
      //     const platform = physics.getBody(hitHandle);
      //     if (platform) {
      //       const forceDown =
      //         -body.mass() * (jumpVel * CharacterMotor.jumpForceToGroundMult[e]);
      //       platform.applyImpulseAtPoint(
      //         { x: 0, y: forceDown, z: 0 },
      //         {
      //           x: GroundProbe.standX[e],
      //           y: GroundProbe.standY[e],
      //           z: GroundProbe.standZ[e],
      //         },
      //         true
      //       );
      //     }
    }

    // --- Falling state ---
    // const isFalling is CharacterState.isFalling[e] generated by ai :)
    const isFalling = cv.y < 0; //&& !CharacterState.canJump[e] ? 1 : 0;

    return; // Pk tout ce qu'il y a apres est la ?
    // --- Falling gravity scale + clamp ---
    const fallingMaxVel = 3; //CharacterMotor.fallingMaxVel[e];
    if (cv.y < fallingMaxVel) {
      if (body.gravityScale() !== 0) body.setGravityScale(0, true);
    } else {
      if (
        !isFalling &&
        body.gravityScale() !== 1 //CharacterMotor.initialGravityScale[e]
      ) {
        body.setGravityScale(1 /*CharacterMotor.initialGravityScale[e]*/, true);
      } else if (
        isFalling &&
        body.gravityScale() !== 2 //CharacterMotor.fallingGravityScale[e]
      ) {
        body.setGravityScale(2 /*CharacterMotor.fallingGravityScale[e]*/, true);
      }
    }
  }
}
